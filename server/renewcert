#!/usr/bin/perl -w

# This file is part of Nivlheim.
#
# Nivlheim is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Nivlheim is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Nivlheim.  If not, see <http://www.gnu.org/licenses/>.


#****************************************************************************************
#	Dette scriptet er den del av Nivlheim-løsningen.
#	Scriptet tar ingen parametre. Det lager et sertifikat,
#	signerer det med Nivlheim-CA og returnerer det.
#	Hostname slås opp i hostinfo-tabellen.
#	Det kreves at klienten allerede bruker et gyldig sertifikat.
#	Det håndheves av Apache httpd ved at dette scriptet ligger i mappen "secure",
#	som skal være konfigurert til å kreve klientsertifikat.
#****************************************************************************************

use strict;
use warnings;
use File::Copy;
use Log::Log4perl;
use MIME::Base64;
use Proc::PID::File;
use DBI;
use Crypt::OpenSSL::X509;

# HTTP Header
print "Content-Type: text/plain\n\n";

# Begrense det til noen få instanser om gangen, fordi openssl bruker lang tid.
# Må fikse en race condition med openssl og, så foreløpig kan vi kun kjøre 1 instans om gangen.
#$_ = `ps -C openssl`;
#if (tr/\n// > 1) {
if (Proc::PID::File->running("dir" => "/tmp")) {
	print "Too busy, please try again later.\n";
	exit;
}

# Config
my $confdir = "/var/www/nivlheim";
Log::Log4perl->init("$confdir/log4perl.conf");
my $logger = Log::Log4perl->get_logger("reqcert");

# Temporary files
my $id = int(rand()*100000000);  # Denne id'en blir kun brukt i denne gjennomkjøringen av scriptet.
my $keyfile = "/tmp/user$id.key";
my $csrfile = "/tmp/user$id.csr";
my $crtfile = "/tmp/user$id.crt";
my $p12file = "/tmp/user$id.p12";

# Compute the client cert fingerprint
my $clientcert = $ENV{'SSL_CLIENT_CERT'};
my $x509 = Crypt::OpenSSL::X509->new_from_string($clientcert);
my $fingerprint = $x509->fingerprint_sha1();

# Determine hostname by looking up the client certificate in the database.
# Use the Common Name as a fallback.
my $hostname;
my $dbh = DBI->connect("dbi:Pg:dbname=nivlheim;host=localhost",
	"nivlheim","yesterday");
if (!$dbh) {
	print $DBI::errstr;
	exit;
}
my @row = $dbh->selectrow_array("SELECT hostname FROM hostinfo WHERE certfp=?",
	undef, ($fingerprint));
if (@row) {
	$hostname = $row[0];
} else {
	if ($x509->subject() =~ /CN=(\S+)/) {
		$hostname = $1;
	}
}
if (!defined($hostname)) {
	print "Unable to determine hostname based on the certificate.";
	$logger->debug("Unable to determine hostname based on the certificate.");
	exit;
}
$dbh->disconnect;
print "Your hostname is: $hostname\n";
$logger->debug("Hostname is: $hostname");

eval {
	# Generate client key
	my $cmd = "openssl genrsa -des3 -passout pass:passord123"
			." -out $keyfile 4096 -config $confdir/openssl_ca.conf 2>/dev/null";

	(system($cmd) == 0 and -f $keyfile) or die "Key generation failed: $?";
	print "Key OK.\n";
	$logger->debug("Key OK.");

	# Generate client certificate request
	$cmd = "openssl req -new -key $keyfile -out $csrfile -passin pass:passord123"
		." -config $confdir/openssl_ca.conf";

	(system($cmd) == 0 and -f $csrfile) or die "Certificate request failed: $?";
	print "Certificate request OK.\n";
	$logger->debug("Certificate request OK.");

	# find the id of the new certificate
	open(F, "$confdir/db/serial") or die "Could not read db/serial";
	$id = <F>; chomp $id;  # 6-sifret sertifikat-id fra openssl
	close(F);
	print "The new id is $id\n";
	$logger->debug("The new id is $id");

	# Sign the certificate request with the CA certificate. This will generate crt- and pem-files.
	# openssl will store the pem-file in the newcerts directory (see openssl.cnf)
	$cmd = "openssl ca -batch -in $csrfile -cert $confdir/CA/nivlheimca.crt"
		." -keyfile $confdir/CA/nivlheimca.key"
		." -subj '/C=NO/ST=Norway/O=UiO/OU=USIT/CN=$hostname'"
		." -out $crtfile -config $confdir/openssl_ca.conf 2>/dev/null";
	if (!(system($cmd) == 0 and -f $crtfile)) {
		$logger->info($cmd);
		die "Signing failed: $?";
	}
	print "Signing OK.\n";

	# Keep a copy of the key/csr/crt-files too
	copy($keyfile, "$confdir/newcerts/$id.key");
	copy($csrfile, "$confdir/newcerts/$id.csr");
	copy($crtfile, "$confdir/newcerts/$id.crt");

	# Generate a P12 file
	$cmd = "openssl pkcs12 -export -out $p12file -inkey $keyfile -in $crtfile "
		. "-CAfile $confdir/CA/nivlheimca.crt -passin pass:password123 -passout pass:password123";
	if (!(system($cmd) == 0 and -f $p12file)) {
		$logger->info($cmd);
		die "P12 failed: $?";
	}
	copy($p12file, "$confdir/newcerts/$id.p12");

	# Display the generated certificate and key
	open(F, $crtfile) or die "Can't read crt file";
	while (<F>) { last if (/--BEGIN CERTIFICATE--/) };
	print; print while (<F>);
	close(F);
	open(F, $keyfile) or die "Can't read key file";
	print while (<F>);
	close(F);

	# Display the P12-file, base64-encoded
	open(F, $p12file);
	my $p12bytes;
	my $len = read(F, $p12bytes, 100000);
	close(F);
	print "-----BEGIN P12-----\n" . encode_base64($p12bytes, "\n") . "-----END P12-----\n";

	$logger->info("Created new cert with id $id for $hostname");
};
if ($@) {
	$logger->error("Failed to create new cert for $hostname: $@");
	print "Failed to create new certificate for $hostname:\n$@\n";
}

# Clean up temp files
unlink($keyfile) if (-f $keyfile);
unlink($csrfile) if (-f $csrfile);
unlink($crtfile) if (-f $crtfile);
unlink($p12file) if (-f $p12file);
